# Stage 7 - Error Recovery and TAC Optimization

## Description

This stage implements error recovery for syntax analysis and TAC (Three-Address Code) optimization. The parser can recover from syntax errors and continue analysis to identify multiple errors in a single execution. The TAC optimizer performs constant folding, dead code elimination, and constant propagation to improve generated code efficiency.

## Main Files

- `parser.ypp` - Grammar with error recovery rules
- `optimizer.hpp` - TAC optimizer interface
- `optimizer.cpp` - TAC optimizer implementation with constant folding and dead code elimination
- `main.cpp` - Main program integrated with TAC optimization
- `Makefile` - Updated to include optimizer compilation
- `relatorio.md` - Report with details of the implementation and tests, written in Portuguese
- `tests/` - Directory containing test files for error recovery and optimization
- `output/` - Directory for output files generated by the compiler

## How to Use

### Compilation

To compile the project, run:

```bash
make
```

or

```bash
make etapa7
```

To compile one of the test files, you can use:

```bash
make test FILE=<test_file>
```

When running with `make test`, it will compile all the source codes and generate in the `output/` directory all the detailed intermediate data structures involved in the compilation process:

- Symbol table in `output/<test_file>_symbol_table.txt`
- AST structure in `output/<test_file>_AST.txt`
- Decompiled code from AST in `output/<test_file>_decompiled.txt`
- TAC instructions in `output/<test_file>_TAC.txt`
- Generated assembly file in `output/<test_file>.s`
- Optimized TAC instructions in `output/<test_file>_TAC_optimized.txt`
- Optimized assembly file in `output/<test_file>_optimized.s`

It will also call the `gcc` command to compile the generated assembly code into an executable, which will be saved in `output/<test_file>.out`.

After this, the command will run the generated executable.

To test the optimization, you can run:

```bash
make optimize FILE=<test_file>
```

This will compile the specified test file and apply the TAC optimizations, generating both the original and optimized TAC files in the `output/` directory. This command does not run the executable, to allow for better testing the optimizations.

### Execution

After compiling, you can run this command to generate the assembly code from a 2025++1 source file:

```bash
./etapa7 <input_file> <symbol_table_output> <ast_output> <decompiled_output> <tac_output> <assembly_output>
```

**Parameters:**

- `input_file`: Source file in 2025++1 language
- `symbol_table_output`: Symbol table output file
- `ast_output`: AST structure output file
- `decompiled_output`: Decompiled code from AST
- `tac_output`: TAC instructions output file (also generates optimized version with .optimized suffix)
- `assembly_output`: Generated assembly file

### Usage Example

```bash
# Compile complete example with optimization
make optimize FILE=tests/functions.2025++1
# Alternatively, you can run:
./etapa7 tests/constant_folding.2025++1 output/constant_folding_symbol_table.txt output/constant_folding_AST.txt output/constant_folding_decompiled.txt output/constant_folding_TAC.txt output/constant_folding.s

# Test error recovery
make test FILE=tests/error_recovery.2025++1
# Alternatively, you can run:
./etapa7 tests/error_recovery.2025++1 output/error_symbol_table.txt output/error_AST.txt output/error_decompiled.txt output/error_TAC.txt output/error.s
```

Don't forget to compile the assembly to an executable, depending on how you want to run the tests:

```bash
gcc output/<test_file>.s -o output/<test_file>.out
```

## Features

### Error Recovery

The parser implements comprehensive error recovery using the `error` token in grammar rules. It can recover from:

- Invalid global declarations (variables, vectors, functions)
- Malformed variable and vector initializations
- Invalid function parameter lists and bodies
- Missing semicolons in statements
- Invalid expressions and control flow conditions
- Syntax errors in assignment, print, read, and return statements

The parser synchronizes at appropriate points and continues analysis to detect multiple errors in a single compilation run.

### TAC Optimization

The optimizer implements three main optimizations:

1. **Constant Folding**: Evaluates arithmetic and logical operations with constant operands at compile time
2. **Dead Code Elimination**: Removes MOVE instructions to unused temporary variables
3. **Constant Propagation**: Substitutes uses of temporaries defined by constants with the original values

The optimizer uses an iterative algorithm that applies multiple passes until no further optimizations are possible, with a safety limit of 1000 passes to prevent infinite loops.

## Code Architecture

### Error Recovery Implementation

- **Synchronization Points**: Strategic placement of error recovery rules at semicolons, braces, and statement boundaries
- **Error Messages**: Specific error messages for each type of syntax error
- **Continued Analysis**: Parser continues after errors to find multiple issues

### TAC Optimizer Functions

- **optimizeTAC()**: Main optimization function that coordinates all optimization passes
- **optimizeConstantFolding()**: Implements constant folding with iterative passes
- **isNumericLiteral()**: Checks if a symbol represents a numeric constant
- **computeConstantExpression()**: Performs arithmetic and logical operations
- **isSymbolUsed()**: Checks if a symbol is referenced in subsequent instructions
- **substituteSymbolUses()**: Replaces symbol occurrences for constant propagation

## File Structure

- `scanner.l`: Lexical analyzer specification
- `parser.ypp`: Syntactic analyzer grammar with error recovery rules
- `ast.hpp` and `ast.cpp`: Abstract Syntax Tree implementation
- `symbol.hpp` and `symbol.cpp`: Symbol table management
- `verifications.hpp` and `verifications.cpp`: Semantic analysis implementation
- `tac.hpp` and `tac.cpp`: Three Address Code generation implementation
- `optimizer.hpp` and `optimizer.cpp`: TAC optimization implementation
- `asm.hpp` and `asm.cpp`: Assembly code generation implementation
- `main.cpp`: Program entry point with integrated optimization
- `Makefile`: Compilation instructions
- `spect7.pdf`: PDF with the specification of this stage, in Portuguese
- `relatorio.md`: Report with details of the implementation and tests, in Portuguese
- `tests/`: Directory with test files for error recovery and optimization testing
- `output/`: Directory for output files generated by the compiler
